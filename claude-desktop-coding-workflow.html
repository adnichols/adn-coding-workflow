<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude Code Development Workflow</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2d3748 0%, #4a5568 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .workflow {
            padding: 40px;
        }
        
        .phase {
            margin-bottom: 30px;
            border: 2px solid #e2e8f0;
            border-radius: 15px;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .phase:hover {
            border-color: #667eea;
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.1);
        }
        
        .phase-header {
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            padding: 20px;
            cursor: pointer;
            display: flex;
            justify-content: between;
            align-items: center;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .phase-header:hover {
            background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
        }
        
        .phase-title {
            font-size: 1.4rem;
            font-weight: 600;
            color: #2d3748;
            flex-grow: 1;
        }
        
        .phase-number {
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
        }
        
        .expand-icon {
            font-size: 1.2rem;
            color: #667eea;
            transition: transform 0.3s ease;
        }
        
        .phase-content {
            padding: 25px;
            display: none;
            background: white;
        }
        
        .phase-content.active {
            display: block;
        }
        
        .phase-header.active .expand-icon {
            transform: rotate(180deg);
        }
        
        .branch-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .branch {
            flex: 1;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            background: #f8fafc;
        }
        
        .branch.feature {
            border-color: #48bb78;
        }
        
        .branch.refactor {
            border-color: #ed8936;
        }
        
        .branch-title {
            font-weight: 600;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid currentColor;
        }
        
        .branch.feature .branch-title {
            color: #48bb78;
        }
        
        .branch.refactor .branch-title {
            color: #ed8936;
        }
        
        .file-list, .command-list, .feature-list {
            list-style: none;
            margin: 15px 0;
        }
        
        .file-list li, .command-list li, .feature-list li {
            padding: 8px 12px;
            margin: 5px 0;
            background: white;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.9rem;
        }
        
        .command-list li {
            border-left-color: #38a169;
            background: #f0fff4;
        }
        
        .feature-list li {
            border-left-color: #3182ce;
            background: #ebf8ff;
            font-family: inherit;
        }
        
        .highlight {
            background: #fef5e7;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ed8936;
            margin: 15px 0;
        }
        
        .connection-line {
            width: 2px;
            height: 20px;
            background: linear-gradient(180deg, #667eea 0%, #764ba2 100%);
            margin: 0 auto;
        }
        
        .quality-checks {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .quality-check {
            background: #f0fff4;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #38a169;
        }
        
        .quality-check h4 {
            color: #38a169;
            margin-bottom: 8px;
        }
        
        .legend {
            background: #f8fafc;
            padding: 20px;
            margin: 30px 0;
            border-radius: 10px;
            border: 2px solid #e2e8f0;
        }
        
        .legend h3 {
            margin-bottom: 15px;
            color: #2d3748;
        }
        
        .legend-items {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        
        .file-resources {
            margin-top: 20px;
        }
        
        .resource-category {
            margin-bottom: 30px;
        }
        
        .resource-category h3 {
            color: #2d3748;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .file-item {
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            margin-bottom: 15px;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .file-item:hover {
            border-color: #667eea;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.1);
        }
        
        .file-header {
            background: linear-gradient(135deg, #f8fafc 0%, #edf2f7 100%);
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 15px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .file-header:hover {
            background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
        }
        
        .file-name {
            font-family: 'Monaco', 'Consolas', monospace;
            font-weight: 600;
            color: #667eea;
            background: white;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #667eea;
        }
        
        .file-desc {
            flex-grow: 1;
            color: #4a5568;
            font-size: 0.95rem;
        }
        
        .toggle-icon {
            color: #667eea;
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }
        
        .file-header.active .toggle-icon {
            transform: rotate(180deg);
        }
        
        .file-content {
            display: none;
            background: #1a202c;
            color: #e2e8f0;
            max-height: 400px;
            overflow-y: auto;
            position: relative;
        }
        
        .file-content.active {
            display: block;
        }
        
        .file-content pre {
            margin: 0;
            padding: 0;
            background: none;
        }
        
        .file-content code {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
            background: none;
            color: inherit;
            padding: 20px;
            padding-top: 50px;
            display: block;
            white-space: pre-wrap;
        }
        
        .copy-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .copy-button:hover {
            background: #5a67d8;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }
        
        .copy-button:active {
            transform: translateY(0);
        }
        
        .copy-button.copied {
            background: #38a169;
        }
        
        .copy-feedback {
            position: absolute;
            top: 10px;
            right: 120px;
            background: #38a169;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 10;
        }
        
        .copy-feedback.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Claude Code Development Workflow</h1>
            <p>A systematic approach to AI-assisted software development</p>
        </div>
        
        <div class="workflow">
            <div class="legend">
                <h3>Workflow Overview</h3>
                <div class="legend-items">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #48bb78;"></div>
                        <span>New Feature Path</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ed8936;"></div>
                        <span>Refactoring Path</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #667eea;"></div>
                        <span>Files & Artifacts</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #38a169;"></div>
                        <span>Commands & Actions</span>
                    </div>
                </div>
            </div>
            
            <div class="phase">
                <div class="phase-header" onclick="togglePhase(this)">
                    <div class="phase-number">1</div>
                    <div class="phase-title">Idea & Initial Specification</div>
                    <div class="expand-icon">▼</div>
                </div>
                <div class="phase-content">
                    <p>Every development cycle starts with an idea that gets refined into a formal specification.</p>
                    
                    <h4>Process:</h4>
                    <ul class="feature-list">
                        <li>Start with a high-level idea or concept</li>
                        <li>Use Claude (desktop or Claude Code) to expand into detailed specification</li>
                        <li>Request structured Markdown documentation</li>
                        <li>Review and refine the specification</li>
                    </ul>
                    
                    <h4>Key Files:</h4>
                    <ul class="file-list">
                        <li>specification.md - Initial idea documentation</li>
                        <li>requirements.md - Refined requirements</li>
                    </ul>
                    
                    <div class="highlight">
                        <strong>Flexibility:</strong> This step can be done in Claude desktop or Claude Code depending on your preference and current context.
                    </div>
                </div>
            </div>
            
            <div class="connection-line"></div>
            
            <div class="phase">
                <div class="phase-header" onclick="togglePhase(this)">
                    <div class="phase-number">🤖</div>
                    <div class="phase-title">Specialized Agents & Commands</div>
                    <div class="expand-icon">▼</div>
                </div>
                <div class="phase-content">
                    <p>The workflow leverages specialized agents and structured commands for different aspects of development.</p>
                    
                    <h4>Command Structure:</h4>
                    <div class="branch-container">
                        <div class="branch feature">
                            <div class="branch-title">📋 Command Categories</div>
                            <ul class="feature-list">
                                <li><strong>user:</strong> Main feature development commands</li>
                                <li><strong>simplify:</strong> Code refactoring and cleanup commands</li>
                                <li><strong>Arguments:</strong> Support file paths and options like NOSUBCONF</li>
                            </ul>
                        </div>
                        
                        <div class="branch refactor">
                            <div class="branch-title">🤖 Specialized Agents</div>
                            <ul class="feature-list">
                                <li><strong>@simplify-planner (Opus):</strong> Code archaeology specialist - identifies complexity accumulation, dead code paths, over-abstractions</li>
                                <li><strong>@quality-reviewer:</strong> Production risk assessor - focuses on data loss, security vulnerabilities, performance killers, concurrency bugs</li>
                                <li><strong>Evidence-Based Approach:</strong> Uses grep/glob analysis, deprecation markers, usage patterns for all decisions</li>
                                <li><strong>ADR Documentation:</strong> Creates Architecture Decision Records with cleanup rationale and safety evidence</li>
                            </ul>
                        </div>
                    </div>
                    
                    <h4>Agent-Specific Focus Areas:</h4>
                    <div class="branch-container">
                        <div class="branch feature">
                            <div class="branch-title">🔍 @simplify-planner Targets</div>
                            <ul class="feature-list">
                                <li><strong>Dead Code:</strong> Unreachable branches, deprecated features with clear markers</li>
                                <li><strong>Over-Abstraction:</strong> Unnecessary layers that add complexity without value</li>
                                <li><strong>Duplication:</strong> Logic that can be safely consolidated</li>
                                <li><strong>Legacy Patterns:</strong> Backward compatibility layers no longer needed</li>
                                <li><strong>Safety Circuit Breakers:</strong> Stops for confirmation on changes affecting >3 packages or core interfaces</li>
                            </ul>
                        </div>
                        
                        <div class="branch refactor">
                            <div class="branch-title">⚠️ @quality-reviewer Categories</div>
                            <ul class="feature-list">
                                <li><strong>MUST FLAG:</strong> Data loss risks, security vulnerabilities, performance killers, concurrency bugs</li>
                                <li><strong>WORTH RAISING:</strong> Logic errors, missing circuit breakers, resource leaks, unnecessary complexity</li>
                                <li><strong>IGNORE:</strong> Style preferences, theoretical edge cases, minor optimizations</li>
                                <li><strong>Focus:</strong> Real production failure risks, not theoretical problems</li>
                            </ul>
                        </div>
                    </div>
                    
                    <h4>Complete Command Reference:</h4>
                    <ul class="command-list">
                        <li>user:create-prd.md - Generate PRD with clarifying questions</li>
                        <li>user:generate-tasks.md [prd-file] - Two-phase task generation</li>
                        <li>user:process-tasks.md [task-file] [NOSUBCONF] - Execute feature tasks</li>
                        <li>simplify:create-plan.md [target-area] - Multi-agent refactor planning</li>
                        <li>simplify:process-plan.md [plan-file] [NOSUBCONF] - Execute cleanup plan</li>
                    </ul>
                    
                    <div class="highlight">
                        <strong>Multi-Agent Orchestration:</strong> The system coordinates between specialized agents with distinct focuses - @simplify-planner for evidence-based complexity reduction and @quality-reviewer for production risk assessment. The @simplify-planner uses the more capable Opus model and creates detailed Architecture Decision Records (ADRs) with safety guarantees, while @quality-reviewer focuses specifically on issues that cause actual production failures rather than theoretical problems.
                    </div>
                </div>
            </div>
            
            <div class="connection-line"></div>
            
            <div class="phase">
                <div class="phase-header" onclick="togglePhase(this)">
                    <div class="phase-number">2</div>
                    <div class="phase-title">Architecture Review & Planning</div>
                    <div class="expand-icon">▼</div>
                </div>
                <div class="phase-content">
                    <p>The specification is reviewed by specialized architecture agents and turned into actionable plans.</p>
                    
                    <div class="branch-container">
                        <div class="branch feature">
                            <div class="branch-title">🚀 New Feature Path</div>
                            <h4>Command:</h4>
                            <ul class="command-list">
                                <li>user:create-prd.md</li>
                            </ul>
                            <h4>Process:</h4>
                            <ul class="feature-list">
                                <li><strong>Clarifying Questions:</strong> Claude asks structured questions with letter/number lists for easy responses</li>
                                <li><strong>Structured PRD:</strong> Generates comprehensive PRD with goals, user stories, requirements, success metrics</li>
                                <li><strong>Junior Dev Ready:</strong> Assumes target audience is a junior developer - explicit and unambiguous</li>
                                <li><strong>Interactive Refinement:</strong> Iterative process to ensure specification captures the full intent</li>
                            </ul>
                        </div>
                        
                        <div class="branch refactor">
                            <div class="branch-title">🔧 Refactoring Path</div>
                            <h4>Command:</h4>
                            <ul class="command-list">
                                <li>simplify:create-plan.md</li>
                            </ul>
                            <h4>Multi-Agent Process:</h4>
                            <ul class="feature-list">
                                <li><strong>@simplify-planner (Opus):</strong> Code archaeology specialist, evidence-based cleanup recommendations</li>
                                <li><strong>@quality-reviewer:</strong> Reviews plan for production failure risks, safety validation</li>
                                <li><strong>Unconditional Preservation:</strong> Guarantees identical user-facing behavior after cleanup</li>
                                <li><strong>Safety Circuit Breakers:</strong> Stops for confirmation on risky changes (>3 packages, core interfaces)</li>
                            </ul>
                        </div>
                    </div>
                    
                    <h4>Output Files:</h4>
                    <ul class="file-list">
                        <li>/tasks/prd-[feature-name].md - Product Requirements Document</li>
                        <li>/tasks/simplify-plan-[area-name].md - Refactoring plan with safety protocols</li>
                    </ul>
                </div>
            </div>
            
            <div class="connection-line"></div>
            
            <div class="phase">
                <div class="phase-header" onclick="togglePhase(this)">
                    <div class="phase-number">3</div>
                    <div class="phase-title">Task List Generation</div>
                    <div class="expand-icon">▼</div>
                </div>
                <div class="phase-content">
                    <p>Plans are broken down into executable task lists using a sophisticated two-phase approach with different workflows for each path.</p>
                    
                    <div class="branch-container">
                        <div class="branch feature">
                            <div class="branch-title">🚀 New Feature Tasks</div>
                            <h4>Command:</h4>
                            <ul class="command-list">
                                <li>user:generate-tasks.md</li>
                            </ul>
                            <h4>Two-Phase Process:</h4>
                            <ul class="feature-list">
                                <li><strong>Phase 1:</strong> Generate ~5 high-level parent tasks</li>
                                <li><strong>Confirmation:</strong> Present tasks and wait for user "Go" approval</li>
                                <li><strong>Phase 2:</strong> Break down each parent into detailed sub-tasks</li>
                                <li><strong>Codebase Analysis:</strong> Reviews existing infrastructure and patterns</li>
                            </ul>
                        </div>
                        
                        <div class="branch refactor">
                            <div class="branch-title">🔧 Refactoring Tasks</div>
                            <p><strong>No additional step needed!</strong></p>
                            <p>The plan created in step 2 already serves as a comprehensive task checklist with four phases:</p>
                            <ul class="feature-list">
                                <li><strong>P1:</strong> Preparation and Safety Verification</li>
                                <li><strong>P2:</strong> Plan Review and Validation</li>
                                <li><strong>P3:</strong> Implementation Steps</li>
                                <li><strong>P4:</strong> Completion and Documentation</li>
                            </ul>
                        </div>
                    </div>
                    
                    <h4>Generated Files:</h4>
                    <ul class="file-list">
                        <li>/tasks/tasks-[prd-file-name].md - Detailed implementation tasks with sub-tasks</li>
                        <li>Relevant files section - Lists all files that need creation/modification</li>
                    </ul>
                </div>
            </div>
            
            <div class="connection-line"></div>
            
            <div class="phase">
                <div class="phase-header" onclick="togglePhase(this)">
                    <div class="phase-number">4</div>
                    <div class="phase-title">Automated Execution</div>
                    <div class="expand-icon">▼</div>
                </div>
                <div class="phase-content">
                    <p>The core implementation phase with sophisticated safety checks, git management, and resumable execution.</p>
                    
                    <div class="branch-container">
                        <div class="branch feature">
                            <div class="branch-title">🚀 Feature Implementation</div>
                            <h4>Command:</h4>
                            <ul class="command-list">
                                <li>user:process-tasks.md [task-file]</li>
                                <li>user:process-tasks.md [task-file] NOSUBCONF</li>
                            </ul>
                        </div>
                        
                        <div class="branch refactor">
                            <div class="branch-title">🔧 Simplification Execution</div>
                            <h4>Command:</h4>
                            <ul class="command-list">
                                <li>simplify:process-plan.md [plan-file]</li>
                                <li>simplify:process-plan.md [plan-file] NOSUBCONF</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="quality-checks">
                        <div class="quality-check">
                            <h4>🌿 Git Branch Safety</h4>
                            <p>Verifies you're on a feature branch, creates one if needed. Never works on main branch.</p>
                        </div>
                        <div class="quality-check">
                            <h4>🧪 Test Suite Integration</h4>
                            <p>Uses TESTING.md/CLAUDE.md protocols. Tests run after each major step and parent task completion.</p>
                        </div>
                        <div class="quality-check">
                            <h4>✅ Real-time Progress Tracking</h4>
                            <p>Updates task checkboxes immediately after completion. No batching - real-time visibility.</p>
                        </div>
                        <div class="quality-check">
                            <h4>🔄 Stateless & Interruptible</h4>
                            <p>All state stored in task files. Can interrupt, switch projects, and resume exactly where you left off.</p>
                        </div>
                        <div class="quality-check">
                            <h4>📝 Conventional Commits</h4>
                            <p>Uses structured commit messages with feat:/fix:/refactor: prefixes and detailed descriptions.</p>
                        </div>
                        <div class="quality-check">
                            <h4>⚡ NOSUBCONF Mode</h4>
                            <p>Optional flag to skip sub-task confirmations for faster automated processing.</p>
                        </div>
                    </div>
                    
                    <div class="highlight">
                        <strong>Execution Philosophy:</strong> One sub-task at a time with immediate progress updates. The system maintains perfect resumability by storing all state in the markdown task files themselves.
                    </div>
                </div>
            </div>
            
            <div class="connection-line"></div>
            
            <div class="phase">
                <div class="phase-header" onclick="togglePhase(this)">
                    <div class="phase-number">5</div>
                    <div class="phase-title">Quality Review & Integration</div>
                    <div class="expand-icon">▼</div>
                </div>
                <div class="phase-content">
                    <p>Multi-layered quality assurance with AI-assisted reviews and human oversight.</p>
                    
                    <h4>Review Stages:</h4>
                    <ul class="feature-list">
                        <li><strong>Initial Quality Review:</strong> Automated review of the complete changeset</li>
                        <li><strong>Feedback Integration:</strong> Claude Code evaluates and implements critical recommendations</li>
                        <li><strong>Pull Request Creation:</strong> Submit changes for team review</li>
                        <li><strong>PR Review:</strong> Additional Claude Code review on the pull request</li>
                        <li><strong>Manual Testing:</strong> Final human verification before merge</li>
                    </ul>
                    
                    <h4>Commands:</h4>
                    <ul class="command-list">
                        <li>quality-review</li>
                        <li>pr-review</li>
                    </ul>
                    
                    <div class="highlight">
                        <strong>Smart Implementation:</strong> Claude Code doesn't blindly implement all recommendations - it evaluates them and prioritizes serious concerns while maintaining code quality.
                    </div>
                </div>
            </div>
            
            <div class="connection-line"></div>
            
            <div class="phase">
                <div class="phase-header" onclick="togglePhase(this)">
                    <div class="phase-number">6</div>
                    <div class="phase-title">Final Integration</div>
                    <div class="expand-icon">▼</div>
                </div>
                <div class="phase-content">
                    <p>The final human-in-the-loop verification before merging changes to main.</p>
                    
                    <h4>Final Steps:</h4>
                    <ul class="feature-list">
                        <li>Manual testing on the feature branch</li>
                        <li>Visual and functional verification</li>
                        <li>Final code review</li>
                        <li>Merge pull request</li>
                        <li>Clean up feature branch</li>
                    </ul>
                    
                    <div class="highlight">
                        <strong>Human Oversight:</strong> While the process is highly automated, human judgment remains critical for final quality assurance and user experience validation.
                    </div>
                </div>
            </div>
        </div>
        
        <div class="workflow">
            <div class="phase">
                <div class="phase-header" onclick="togglePhase(this)">
                    <div class="phase-number">📁</div>
                    <div class="phase-title">Workflow Files & Resources</div>
                    <div class="expand-icon">▼</div>
                </div>
                <div class="phase-content">
                    <p>Complete collection of command files and agent configurations needed to implement this workflow. Click each file to view its contents and copy for your own setup.</p>
                    
                    <div class="file-resources">
                        <div class="resource-category">
                            <h3>Core Workflow Commands</h3>
                            
                            <div class="file-item">
                                <div class="file-header" onclick="toggleFileContent(this)">
                                    <span class="file-name">user:create-prd.md</span>
                                    <span class="file-desc">Creates PRD with interactive clarification questions</span>
                                    <span class="toggle-icon">▼</span>
                                </div>
                                <div class="file-content">
                                    <pre><code># Rule: Generating a Product Requirements Document (PRD)

## Goal

To guide an AI assistant in creating a detailed Product Requirements Document (PRD) in Markdown format, based on an initial user prompt. The PRD should be clear, actionable, and suitable for a junior developer to understand and implement the feature. Think harder.

## Process

1.  **Receive Initial Prompt:** The user provides a brief description or request for a new feature or functionality.
2.  **Ask Clarifying Questions:** Before writing the PRD, the AI _must_ ask clarifying questions to gather sufficient detail. The goal is to understand the "what" and "why" of the feature, not necessarily the "how" (which the developer will figure out). Make sure to provide options in letter/number lists so I can respond easily with my selections.
3.  **Generate PRD:** Based on the initial prompt and the user's answers to the clarifying questions, generate a PRD using the structure outlined below.
4.  **Save PRD:** Save the generated document as `prd-[feature-name].md` inside the `/tasks` directory.

## Clarifying Questions (Examples)

The AI should adapt its questions based on the prompt, but here are some common areas to explore:

- **Problem/Goal:** "What problem does this feature solve for the user?" or "What is the main goal we want to achieve with this feature?"
- **Target User:** "Who is the primary user of this feature?"
- **Core Functionality:** "Can you describe the key actions a user should be able to perform with this feature?"
- **User Stories:** "Could you provide a few user stories? (e.g., As a [type of user], I want to [perform an action] so that [benefit].)"
- **Acceptance Criteria:** "How will we know when this feature is successfully implemented? What are the key success criteria?"
- **Scope/Boundaries:** "Are there any specific things this feature _should not_ do (non-goals)?"
- **Data Requirements:** "What kind of data does this feature need to display or manipulate?"
- **Design/UI:** "Are there any existing design mockups or UI guidelines to follow?" or "Can you describe the desired look and feel?"
- **Edge Cases:** "Are there any potential edge cases or error conditions we should consider?"

## PRD Structure

The generated PRD should include the following sections:

1.  **Introduction/Overview:** Briefly describe the feature and the problem it solves. State the goal.
2.  **Goals:** List the specific, measurable objectives for this feature.
3.  **User Stories:** Detail the user narratives describing feature usage and benefits.
4.  **Functional Requirements:** List the specific functionalities the feature must have. Use clear, concise language (e.g., "The system must allow users to upload a profile picture."). Number these requirements.
5.  **Non-Goals (Out of Scope):** Clearly state what this feature will _not_ include to manage scope.
6.  **Design Considerations (Optional):** Link to mockups, describe UI/UX requirements, or mention relevant components/styles if applicable.
7.  **Technical Considerations (Optional):** Mention any known technical constraints, dependencies, or suggestions (e.g., "Should integrate with the existing Auth module").
8.  **Success Metrics:** How will the success of this feature be measured? (e.g., "Increase user engagement by 10%", "Reduce support tickets related to X").
9.  **Open Questions:** List any remaining questions or areas needing further clarification.

## Target Audience

Assume the primary reader of the PRD is a **junior developer**. Therefore, requirements should be explicit, unambiguous, and avoid jargon where possible. Provide enough detail for them to understand the feature's purpose and core logic.

## Output

- **Format:** Markdown (`.md`)
- **Location:** `/tasks/`
- **Filename:** `prd-[feature-name].md`

## Final instructions

1. Do NOT start implementing the PRD
2. Make sure to ask the user clarifying questions
3. Take the user's answers to the clarifying questions and improve the PRD</code></pre>
                                </div>
                            </div>
                            
                            <div class="file-item">
                                <div class="file-header" onclick="toggleFileContent(this)">
                                    <span class="file-name">user:generate-tasks.md</span>
                                    <span class="file-desc">Two-phase task generation from PRD</span>
                                    <span class="toggle-icon">▼</span>
                                </div>
                                <div class="file-content">
                                    <pre><code># Rule: Generating a Task List from a PRD

## Goal

To guide an AI assistant in creating a detailed, step-by-step task list in Markdown format based on an existing Product Requirements Document (PRD). The task list should guide a developer through implementation. Think harder.

## Output

- **Format:** Markdown (`.md`)
- **Location:** `/tasks/`
- **Filename:** `tasks-[prd-file-name].md` (e.g., `tasks-prd-user-profile-editing.md`)

## Process

1.  **Receive PRD Reference:** The user points the AI to a specific PRD file
2.  **Analyze PRD:** The AI reads and analyzes the functional requirements, user stories, and other sections of the specified PRD.
3.  **Assess Current State:** Review the existing codebase to understand existing infrastructre, architectural patterns and conventions. Also, identify any existing components or features that already exist and could be relevant to the PRD requirements. Then, identify existing related files, components, and utilities that can be leveraged or need modification.
4.  **Phase 1: Generate Parent Tasks:** Based on the PRD analysis and current state assessment, create the file and generate the main, high-level tasks required to implement the feature. Use your judgement on how many high-level tasks to use. It's likely to be about 5. Present these tasks to the user in the specified format (without sub-tasks yet). Inform the user: "I have generated the high-level tasks based on the PRD. Ready to generate the sub-tasks? Respond with 'Go' to proceed."
5.  **Wait for Confirmation:** Pause and wait for the user to respond with "Go".
6.  **Phase 2: Generate Sub-Tasks:** Once the user confirms, break down each parent task into smaller, actionable sub-tasks necessary to complete the parent task. Ensure sub-tasks logically follow from the parent task, cover the implementation details implied by the PRD, and consider existing codebase patterns where relevant without being constrained by them.
7.  **Identify Relevant Files:** Based on the tasks and PRD, identify potential files that will need to be created or modified. List these under the `Relevant Files` section, including corresponding test files if applicable.
8.  **Generate Final Output:** Combine the parent tasks, sub-tasks, relevant files, and notes into the final Markdown structure.
9.  **Save Task List:** Save the generated document in the `/tasks/` directory with the filename `tasks-[prd-file-name].md`, where `[prd-file-name]` matches the base name of the input PRD file (e.g., if the input was `prd-user-profile-editing.md`, the output is `tasks-prd-user-profile-editing.md`).

## Output Format

The generated task list _must_ follow this structure:

```markdown
## Relevant Files

- `path/to/potential/file1.ts` - Brief description of why this file is relevant (e.g., Contains the main component for this feature).
- `path/to/file1.test.ts` - Unit tests for `file1.ts`.
- `path/to/another/file.tsx` - Brief description (e.g., API route handler for data submission).
- `path/to/another/file.test.tsx` - Unit tests for `another/file.tsx`.
- `lib/utils/helpers.ts` - Brief description (e.g., Utility functions needed for calculations).
- `lib/utils/helpers.test.ts` - Unit tests for `helpers.ts`.

### Notes

- Use test commands defined in TESTING.md or CLAUDE.md.

## Tasks

- [ ] 1.0 Parent Task Title
  - [ ] 1.1 [Sub-task description 1.1]
  - [ ] 1.2 [Sub-task description 1.2]
- [ ] 2.0 Parent Task Title
  - [ ] 2.1 [Sub-task description 2.1]
- [ ] 3.0 Parent Task Title (may not require sub-tasks if purely structural or configuration)
```

## Interaction Model

The process explicitly requires a pause after generating parent tasks to get user confirmation ("Go") before proceeding to generate the detailed sub-tasks. This ensures the high-level plan aligns with user expectations before diving into details.

## Target Audience

Assume the primary reader of the task list is a **junior developer** who will implement the feature with awareness of the existing codebase context.

# Task List Management

Guidelines for managing task lists in markdown files to track progress on completing a PRD

## Task Implementation

- **One sub-task at a time:** Do **NOT** start the next subâ€'task until you ask the user for permission and they say "yes" or "y"
- **Completion protocol:**
  1. When you finish a **subâ€'task**, immediately mark it as completed by changing `[ ]` to `[x]`.
  2. If **all** subtasks underneath a parent task are now `[x]`, follow this sequence:
  - **First**: Run the full test suite as defined in TESTING.md or CLAUDE.md
  - **Only if all tests pass**: Stage changes (`git add .`)
  - **Clean up**: Remove any temporary files and temporary code before committing
  - **Commit**: Use a descriptive commit message that:
    - Uses conventional commit format (`feat:`, `fix:`, `refactor:`, etc.)
    - Summarizes what was accomplished in the parent task
    - Lists key changes and additions
    - References the task number and PRD context
    - **Formats the message as a single-line command using `-m` flags**, e.g.:

      ```
      git commit -m "feat: add payment validation logic" -m "- Validates card type and expiry" -m "- Adds unit tests for edge cases" -m "Related to T123 in PRD"
      ```
  3. Once all the subtasks are marked completed and changes have been committed, mark the **parent task** as completed.

- Stop after each subâ€'task and wait for the user's goâ€'ahead.

## Task List Maintenance

1. **Update the task list as you work:**
   - Mark tasks and subtasks as completed (`[x]`) per the protocol above.
   - Add new tasks as they emerge.

2. **Maintain the "Relevant Files" section:**
   - List every file created or modified.
   - Give each file a oneâ€'line description of its purpose.

## AI Instructions

When working with task lists, the AI must:

1. Regularly update the task list file after finishing any significant work.
2. Follow the completion protocol:
   - Mark each finished **subâ€'task** `[x]`.
   - Mark the **parent task** `[x]` once **all** its subtasks are `[x]`.
3. Add newly discovered tasks.
4. Keep "Relevant Files" accurate and up to date.
5. Before starting work, check which subâ€'task is next.
6. After implementing a subâ€'task, update the file and then pause for user approval.</code></pre>
                                </div>
                            </div>

                            <div class="file-item">
                                <div class="file-header" onclick="toggleFileContent(this)">
                                    <span class="file-name">user:process-tasks.md</span>
                                    <span class="file-desc">Executes feature tasks with safety protocols</span>
                                    <span class="toggle-icon">▼</span>
                                </div>
                                <div class="file-content">
                                    <button class="copy-button" onclick="copyFileContent(this)">Copy</button>
                                    <div class="copy-feedback">Copied!</div>
                                    <pre><code>---
description: Process tasks in a task list
argument-hint: [Files]
---

# Instructions

Take the tasks (either in a list or a file) below and process them according to the instructions in Task List Management
$ARGUMENTS. Think harder.

<skip_subtask_confirmation>
If $ARGUMENTS contains NOSUBCONF then ignore subtask confirmation in task implementation below
</skip_subtask_confirmation>

# Task List Management

Guidelines for managing task lists in markdown files to track progress on completing a PRD

## Task Implementation

- Do not proceed with tasks unless you are on a git branch other than main
- If needed, create a branch for the phase of work you are implementing
  - Parent agent (you) are responsible for git branch creation, not subagents
- **One sub-task at a time:** Do **NOT** start the next subâ€'task until you ask the user for permission and they say "yes" or "y" UNLESS NOSUBCONF is specified by the user
- **Completion protocol:**
  1. When you finish a **subâ€'task**, immediately mark it as completed by changing `[ ]` to `[x]`.
  2. If **all** subtasks underneath a parent task are now `[x]`, follow this sequence:
  - **First**: Run the full test suite as defined in TESTING.md or CLAUDE.md
  - **Only if all tests pass**: Stage changes (`git add .`)
  - **Clean up**: Remove any temporary files and temporary code before committing
  - **Commit**: Use a descriptive commit message that:
    - Uses conventional commit format (`feat:`, `fix:`, `refactor:`, etc.)
    - Summarizes what was accomplished in the parent task
    - Lists key changes and additions
    - References the task number and PRD context
    - **Formats the message as a single-line command using `-m` flags**, e.g.:

      ```
      git commit -m "feat: add payment validation logic" -m "- Validates card type and expiry" -m "- Adds unit tests for edge cases" -m "Related to T123 in PRD"
      ```
  3. Once all the subtasks are marked completed and changes have been committed, mark the **parent task** as completed.

- Stop after each subâ€'task and wait for the user's goâ€'ahead UNLESS NOSUBCONF is specified by the user

- Always stop after parent tasks complete, run test suite, and commit changes

## Task List Maintenance

1. **Update the task list as you work:**
   - Mark tasks and subtasks as completed (`[x]`) per the protocol above.
   - Add new tasks as they emerge.

2. **Maintain the "Relevant Files" section:**
   - List every file created or modified.
   - Give each file a oneâ€'line description of its purpose.

## AI Instructions

When working with task lists, the AI must:

1. Regularly update the task list file after finishing any significant work.
2. Follow the completion protocol:
   - Mark each finished **subâ€'task** `[x]`.
   - Mark the **parent task** `[x]` once **all** its subtasks are `[x]`.
3. Add newly discovered tasks.
4. Keep "Relevant Files" accurate and up to date.
5. Before starting work, check which subâ€'task is next.
6. After implementing a subâ€'task, update the file and then pause for user approval.</code></pre>
                                </div>
                            </div>
                            
                            <div class="file-item">
                                <div class="file-header" onclick="toggleFileContent(this)">
                                    <span class="file-name">simplify:create-plan.md</span>
                                    <span class="file-desc">Creates evidence-based refactoring plans</span>
                                    <span class="toggle-icon">▼</span>
                                </div>
                                <div class="file-content">
                                    <pre><code>---
description: Create a code simplification plan using the simplify-planner agent
argument-hint: [Target directory/files to analyze]
---

# Rule: Generating a Code Simplification Plan

## Goal

To guide an AI assistant in creating a detailed Code Simplification Plan using the @simplify-planner agent. The plan should identify complexity accumulation, provide evidence-based cleanup recommendations, and ensure absolute preservation of core functionality. Think harder.

## Process

1. **Receive Target Scope:** The user provides a directory path, file pattern, or specific files to analyze for simplification opportunities. If not provided, review entire current directory.
2. **Assure working branch:** Assure we are operating on a feature branch and if we aren't, create an appropriate branch for these changes
3. **Review Recent Changes:** Leverage git history to identify recent changes to the current repository
4. **Test Coverage Assessment:** Verify existing test coverage for the target area before any simplification planning.
5. **Generate Simplification Plan:** Use the @simplify-planner agent to analyze the codebase and create a detailed plan.
6. **Quality Review:** Have the @quality-reviewer agent review the plan for safety and completeness.
7. **Save Plan:** Save the generated plan as `simplify-plan-[area-name].md` inside the `/tasks` directory.

## Pre-Simplification Requirements

Before generating any simplification plan:

1. **Test Coverage Verification:**
   - Analyze existing test coverage for the target area
   - Identify gaps in test coverage for core functionality
   - Document current test structure and quality
   - Favor fewer end to end tests over detailed unit tests
   - Minimize mocks and stubs where possible, use real scenarios

2. **Recent Change Analysis:**
   - Review git history for recent modifications
   - Identify areas of frequent change or bug fixes
   - Understand evolution patterns and complexity accumulation

3. **Dependency Mapping:**
   - Identify all external dependencies on the target code
   - Map integration points and API contracts
   - Document concurrent behavior and thread safety requirements

## Simplification Plan Structure

The generated plan should include the following sections as a checklist:

### Phase 1: Preparation and Safety Verification
- [ ] **P1.1: Baseline Test Execution**
  - [ ] Run full test suite to establish baseline
  - [ ] Document current test coverage percentage
  - [ ] Identify any existing test failures

- [ ] **P1.2: Test Coverage Enhancement** (if needed)
  - [ ] Create missing unit tests for core functionality
  - [ ] Add integration tests for critical paths
  - [ ] Implement regression tests for identified edge cases

- [ ] **P1.3: Complexity Analysis**
  - [ ] Complete @simplify-planner codebase archaeology
  - [ ] Document evidence of unused/deprecated code
  - [ ] Identify consolidation opportunities
  - [ ] Map preservation requirements

### Phase 2: Plan Review and Validation
- [ ] **P2.1: Quality Review**
  - [ ] Submit plan to @quality-reviewer agent
  - [ ] Update plan to address safety concerns or gaps as appropriate
  - [ ] Confirm preservation guarantees

- [ ] **P2.2: Risk Assessment**
  - [ ] Document all identified risks
  - [ ] Create mitigation strategies
  - [ ] Define success criteria
  - [ ] Establish monitoring approach

- [ ] **P2.3: Plan Summary and User Review**
  - [ ] Provide comprehensive summary of proposed changes
  - [ ] Highlight all areas to be modified and cleanup targets
  - [ ] Present risk assessment and mitigation strategies
  - [ ] Wait for explicit user approval before proceeding
  - [ ] Address any user concerns or modifications
  - [ ] Do NOT proceed to Phase 3 without user confirmation

### Phase 3: Implementation Steps
- [ ] **P3.1: Pre-Implementation Verification**
  - [ ] Re-run full test suite
  - [ ] Create git branch for simplification work
  - [ ] Document current system state

- [ ] **P3.2: Surgical Cleanup Execution**
  - [ ] [Specific cleanup step 1]
  - [ ] [Specific cleanup step 2]
  - [ ] [Specific cleanup step N]

- [ ] **P3.3: Post-Cleanup Validation**
  - [ ] Run full test suite after each major cleanup
  - [ ] Verify functionality preservation
  - [ ] Performance regression testing
  - [ ] Integration point validation

### Phase 4: Completion and Documentation
- [ ] **P4.1: Final Verification**
  - [ ] Complete system integration testing
  - [ ] User acceptance criteria validation
  - [ ] Performance benchmarking

- [ ] **P4.2: Documentation and Cleanup**
  - [ ] Update code documentation
  - [ ] Remove temporary files and artifacts
  - [ ] Create deployment notes
  - [ ] Archive simplification artifacts

## Agent Responsibilities

### Current Agent (Orchestrator)
- Plan creation and coordination
- Git branch management
- Progress tracking and checklist updates
- Quality gates and safety verification

### @simplify-planner Agent
- Codebase complexity analysis
- Evidence-based cleanup recommendations
- Preservation strategy design
- Risk identification and mitigation planning

### @quality-reviewer Agent
- Plan safety review
- Risk assessment validation
- Quality gate approval

## Safety Requirements

1. **Unconditional Functionality Preservation:**
   - All user-facing behavior must remain identical
   - No core functionality degradation allowed
   - All integration points must remain intact

2. **Evidence-Based Decisions:**
   - Concrete proof required for all removal decisions
   - Usage analysis with grep/git evidence
   - Deprecation timeline documentation

3. **Comprehensive Testing:**
   - Test coverage must be adequate before cleanup
   - Performance benchmarks maintained

4. **Rollback Preparedness:**
   - Git branch strategy for safe experimentation
   - Rollback involves reverting git changes, keep risky changes on their own commit

## Output

- **Format:** Markdown (`.md`)
- **Location:** `/tasks/`
- **Filename:** `simplify-plan-[area-name].md`

## Final Instructions

1. Do NOT start implementing any simplification
2. Ensure all checklist items are specific and actionable
3. Verify @simplify-planner agent provides evidence for all recommendations
4. Incorporate @quality-reviewer feedback into the plan where appropriate before proceeding
5. Remember: This creates the PLAN only - execution happens via simplify:process-plan.md</code></pre>
                                </div>
                            </div>
                            
                            <div class="file-item">
                                <div class="file-header" onclick="toggleFileContent(this)">
                                    <span class="file-name">simplify:process-plan.md</span>
                                    <span class="file-desc">Executes refactoring plans with safety validation</span>
                                    <span class="toggle-icon">▼</span>
                                </div>
                                <div class="file-content">
                                    <pre><code>---
description: Process and execute a code simplification plan created by simplify:create-plan.md
argument-hint: [Plan file path] [Options: NOSUBCONF]
---

# Instructions

Execute the code simplification plan step by step according to the Plan Processing Protocol below.
$ARGUMENTS. Think harder.

<skip_subtask_confirmation>
If $ARGUMENTS contains NOSUBCONF then ignore step confirmation in plan execution below
</skip_subtask_confirmation>

<plan_file_tracking>
CRITICAL: Always track and update the plan file throughout execution:
- Extract plan file path from first argument
- Store plan file path as PLAN_FILE variable
- Update checkboxes using search_replace tool after each completed step
- Verify checkbox updates by reading back the plan file
- Never lose track of which plan file you're processing
</plan_file_tracking>

# Plan Processing Protocol

Guidelines for safely executing code simplification plans while preserving functionality and tracking progress.

## Critical Safety Requirements

### Functionality Preservation Protocol
1. **Baseline Establishment:**
   - Run full test suite BEFORE any changes
   - Document current system state and behavior
   - Establish performance benchmarks
   - Record current test coverage metrics

2. **Change Validation:**
   - Run full test suite AFTER each major step
   - Compare results to baseline - ANY degradation = STOP
   - Validate integration points remain functional
   - Verify performance regressions are within acceptable bounds

3. **Failure Response:**
   - If ANY test fails that previously passed: **STOP IMMEDIATELY**
   - Do not continue to next step
   - Alert user with specific failure details
   - Provide rollback instructions
   - Wait for user decision before proceeding

## Plan Execution Rules

### Branch Management
- Do not proceed unless you are on a git branch other than main
- If needed, create a branch specifically for this simplification work
- Branch naming: `simplify/[area-name]-[date]`

### Step-by-Step Execution
- **Execute steps IN ORDER:** Follow the checklist sequence exactly
- **One step at a time:** Complete current step fully before starting next
- **No delegation:** Do NOT delegate execution to subagents - execute directly
- **IMMEDIATE Progress tracking:** Update checkbox to `[x]` using search_replace tool THE MOMENT each sub-task is done
- **NO BATCHING:** Never wait until end of phase to update multiple checkboxes - update each one immediately
- **Real-time visibility:** User should see progress in real-time by checking the plan file

### Confirmation Protocol
- **Stop after each major step** and wait for user's go-ahead
- **UNLESS NOSUBCONF is specified:** Then proceed automatically between steps
- **Always stop after phases complete:** Wait for user confirmation between phases
- **Always stop on any test failure:** Immediate user notification required

## Checkbox Update Protocol

### CRITICAL: Plan File Checkbox Management

**Before Starting Any Plan Processing:**
1. **Extract Plan File Path:** Get the plan file path from the first argument
2. **Store as Variable:** Maintain PLAN_FILE variable throughout execution
3. **Initial Verification:** Read the plan file to understand current state

**For Each Completed Step:**
1. **Identify Target Checkbox:** Locate the specific `- [ ]` checkbox for the completed step
2. **Use search_replace Tool:** Replace `- [ ]` with `- [x]` for that specific step
3. **Include Sufficient Context:** Use enough surrounding text to make the replacement unique
4. **Verify Update:** Read back the modified section to confirm checkbox was updated
5. **Handle Nested Checkboxes:** For sub-items, update both the sub-item and parent as appropriate

**Example Real-Time Checkbox Update Workflow:**
```
# Step 1: Start sub-task
"I'm now working on P2.1 - Create tests/debug/ directory"

# Step 2: Complete the sub-task
[Execute: mkdir tests/debug/]

# Step 3: IMMEDIATELY update checkbox (DO NOT WAIT)
[Use search_replace to change:]
Old: "- [ ] Create `tests/debug/` directory"
New: "- [x] Create `tests/debug/` directory"

# Step 4: Verify update worked
[Read plan file to confirm checkbox is now [x]]

# Step 5: Move to next sub-task
"Now I'm working on the next sub-task: Copy test files"

# WRONG APPROACH:
"I'll complete all the file operations and then update all checkboxes at once"

# CORRECT APPROACH:
Complete one thing → Update one checkbox → Complete next thing → Update next checkbox
```

**Troubleshooting Failed Updates:**
- If search_replace fails, read the plan file again to see current state
- Check for formatting differences (spaces, indentation, text variations)
- Use more specific context to make the target unique
- Try updating sub-items first, then parent items
- If still failing, try updating with more surrounding context lines
- **NEVER SKIP CHECKBOX UPDATES** - if all else fails, ask user for help with the specific update
- Document the exact error and what you tried for user assistance

## Step Processing Workflow

### For Each Step in the Plan:

1. **Pre-Step Verification:**
   ```
   - [ ] Current step: [Step Description]
   - [ ] Verify all prerequisite steps are complete
   - [ ] Run baseline tests if this is a code-changing step
   - [ ] Document current state
   ```

2. **Step Execution:**
   ```
   - [ ] Execute the specific step actions
   - [ ] For code changes: Implement changes directly (no subagent delegation)
   - [ ] For test creation: Write tests directly
   - [ ] For verification: Run specified validation
   - [ ] IMMEDIATELY after completion: Update checkbox from [ ] to [x] using search_replace
   - [ ] Verify the checkbox update was successful by reading the plan file
   ```

3. **Post-Step Validation:**
   ```
   - [ ] Mark step as completed [x] in plan file using search_replace tool
   - [ ] Verify checkbox update by reading plan file section
   - [ ] Run test suite if code was modified
   - [ ] Compare results to baseline
   - [ ] Document any changes or observations
   - [ ] Update "Relevant Files" section
   ```

4. **Safety Gate:**
   ```
   - [ ] All tests pass (or explain any expected changes)
   - [ ] No functionality regressions detected
   - [ ] Performance within acceptable bounds
   - [ ] Integration points still functional
   ```

5. **Progress Update:**
   ```
   - [ ] Update plan file with completed step
   - [ ] Add any newly discovered issues or risks
   - [ ] Note time taken and any challenges encountered
   ```

**MANDATORY CHECKPOINT - DO NOT PROCEED TO NEXT STEP UNTIL:**
- [ ] Current step checkbox is marked [x] in the plan file
- [ ] Checkbox update has been verified by reading the plan file back
- [ ] User can see progress by checking the plan file

**ANTI-BATCHING ENFORCEMENT:**
- ❌ WRONG: Complete 5 sub-tasks, then update all 5 checkboxes at once
- ✅ CORRECT: Complete sub-task 1 → Update checkbox 1 → Complete sub-task 2 → Update checkbox 2 → etc.
- ❌ WRONG: "I'll update all the checkboxes after I finish this phase"
- ✅ CORRECT: "I just completed task X, let me update its checkbox immediately"

## Phase Completion Protocol

When all steps in a phase are marked `[x]`:

1. **Full Validation:**
   - Run complete test suite as defined in TESTING.md or CLAUDE.md
   - Verify all functionality preservation requirements
   - Check performance benchmarks
   - Validate integration points

2. **Git Management:**
   - Stage changes: `git add .`
   - Clean up temporary files and artifacts
   - Commit with descriptive message using conventional format:
     ```
     git commit -m "refactor: [phase description]" -m "- [key changes made]" -m "- [preservation verifications]" -m "Related to simplify-plan-[area-name]"
     ```

3. **Documentation:**
   - Update plan file with phase completion
   - Document any lessons learned or issues encountered
   - Update risk assessment if needed

4. **User Confirmation:**
   - Always stop and wait for user approval before next phase
   - Provide summary of phase accomplishments
   - Highlight any concerns or deviations from plan

## Progress Tracking

### Plan File Maintenance
1. **Real-time Updates:**
   - Mark steps `[x]` immediately upon completion using search_replace tool
   - Verify each checkbox update by reading the modified section back
   - Add newly discovered tasks as they emerge
   - Update risk assessments based on findings
   - NEVER skip checkbox updates - they are required for progress tracking

2. **Relevant Files Section:**
   - List every file created, modified, or deleted
   - Provide one-line description of changes made
   - Track test files separately from implementation files

3. **Issues and Risks Section:**
   - Document any unexpected challenges
   - Record deviations from original plan
   - Note any functionality concerns discovered

## Error Handling and Recovery

### Test Failure Response
1. **Immediate Actions:**
   - Stop all further execution
   - Document the exact test failure details
   - Identify what changed since last successful test run
   - Capture system state for debugging

2. **User Communication:**
   - Alert user with clear failure description
   - Provide specific error messages and logs
   - Suggest potential rollback options
   - Wait for explicit user decision on how to proceed

3. **Recovery Options:**
   - Rollback last change and retry
   - Debug and fix the issue before continuing
   - Skip problematic step and mark as deferred
   - Abort simplification plan entirely

### Git Safety Net
- Each phase should be a clean commit point
- Easy rollback to any previous stable state
- Clear commit messages for easy navigation
- Branch isolation from main codebase

## Success Criteria

A step is considered complete when:
- [ ] All step actions have been executed
- [ ] Step is marked `[x]` in plan file using search_replace tool
- [ ] Checkbox update verified by reading plan file back
- [ ] All tests pass (or degradation is explained and approved)
- [ ] No functionality regressions detected
- [ ] User has confirmed (unless NOSUBCONF specified)

A phase is considered complete when:
- [ ] All steps in phase are marked `[x]`
- [ ] Full test suite passes
- [ ] Git commit created with changes
- [ ] Documentation updated
- [ ] User approval received for next phase

The entire plan is complete when:
- [ ] All phases marked complete
- [ ] Final integration testing passed
- [ ] Performance benchmarks maintained
- [ ] All temporary artifacts cleaned up
- [ ] Completion documented in plan file

## Plan Processing Initialization

### REQUIRED: Start of Plan Processing Workflow

**Step 1: Plan File Setup**
```bash
# Extract plan file path from arguments
PLAN_FILE="$1"  # First argument should be plan file path
echo "Processing plan file: $PLAN_FILE"
```

**Step 2: Initial Plan File Analysis**
- Read the entire plan file to understand current state
- Identify which phases/steps are already completed `[x]`
- Identify the next uncompleted step to work on `[ ]`
- Verify file is writable and accessible

**Step 3: Establish Progress Tracking**
- Create a system for tracking which step you're currently working on
- Note the exact text of checkboxes that need updating
- Plan the search/replace strings for checkbox updates

**Step 4: Begin Step-by-Step Execution**
- Follow the Step Processing Workflow below
- Update checkboxes after each completed step
- Never proceed without updating progress in plan file

## AI Instructions for Plan Processing

When processing simplification plans, the AI must:

1. **Follow the safety protocol absolutely:**
   - Never skip test validation
   - Never continue after test failures
   - Never delegate execution to subagents
   - **CRITICAL: Never skip checkbox updates - this is MANDATORY for progress tracking**

2. **Maintain detailed progress tracking:**
   - Update plan file after every significant action using search_replace tool
   - Mark steps complete immediately with `[x]` checkbox updates
   - Verify each checkbox update by reading the modified section
   - Document issues and deviations promptly
   - Never proceed to next step without updating current step checkbox

3. **Execute steps directly:**
   - Implement code changes personally
   - Write tests directly
   - Run validations without delegation

4. **Preserve functionality unconditionally:**
   - Validate preservation after every change
   - Stop immediately on any regression
   - Prioritize safety over speed

5. **Communicate clearly with user:**
   - Provide detailed status updates
   - Alert immediately on any issues
   - Ask for guidance when uncertain

6. **CRITICAL: Prevent checkbox batching behavior:**
   - Update ONE checkbox immediately after completing ONE sub-task
   - Never accumulate multiple completed tasks before updating checkboxes
   - Think: "Task done → Update checkbox → Next task" not "All tasks done → Update all checkboxes"
   - This provides real-time progress visibility to the user

Remember: The goal is safe, systematic simplification with absolute functionality preservation. Speed is secondary to safety and correctness.</code></pre>
                                </div>
                            </div>
                        </div>
                        
                        <div class="resource-category">
                            <h3>Specialized Agent Configurations</h3>
                            
                            <div class="file-item">
                                <div class="file-header" onclick="toggleFileContent(this)">
                                    <span class="file-name">simplify-planner.md</span>
                                    <span class="file-desc">Code archaeology specialist agent (Opus model)</span>
                                    <span class="toggle-icon">▼</span>
                                </div>
                                <div class="file-content">
                                    <pre><code>---
name: simplify-planner
description: Code cleanup specialist - identifies complexity accumulation, deprecated code, and simplification opportunities while guaranteeing core functionality preservation
model: opus
color: purple
---

# Description

You are a Senior Software Architect specializing in code archaeology and complexity reduction. You identify where codebases have accumulated unnecessary complexity over time and design surgical cleanup plans that eliminate cruft while preserving every bit of core functionality. Think harder.

## RULE 0 (MOST IMPORTANT): Refactor planning only, no implementation

<primary_directive>
You NEVER write implementation code. You analyze, design, and write detailed specifications.
Any attempt to write actual code files is a critical failure (-$1000).
</primary_directive>

## Project-Specific Guidelines

ALWAYS check CLAUDE.md for:

- Architecture patterns and principles
- Error handling requirements
- Technology-specific considerations
- Design constraints

<output_handling>
Always write your specification out to a descriptive filename in the `tasks/` directory of the project
</output_handling>

## Core Mission

You specialize in identifying and eliminating complexity that has accumulated in codebases over time.
Your focus: surgical removal of cruft, deprecated patterns, and unnecessary abstractions while maintaining perfect functional equivalence.

**Analysis Flow:** Codebase archaeology → Complexity identification → Cleanup strategy → Preservation verification

<critical_requirement>
UNCONDITIONAL GUARANTEE: No core functionality shall be lost, modified, or degraded in any refactor.
All user-facing behavior must remain COMPLETELY IDENTICAL after cleanup.
Only explicitly deprecated or unused code paths may be removed, and ONLY with clear evidence of non-usage.
Functional equivalence violation is a COMPLETE FAILURE (-$1000).
</critical_requirement>

IMPORTANT: Do what has been asked; nothing more, nothing less.

## Primary Responsibilities

### 1. Complexity Archaeology

Read relevant code with Grep/Glob (targeted, not exhaustive). Identify:

**Core Functionality (MUST PRESERVE):**
- Active user-facing features and their exact behavior
- Integration points and dependencies that are actively used
- Business logic that drives current product functionality

**Cleanup Opportunities:**
- Dead code paths and unreachable branches
- Deprecated features with clear deprecation markers
- Backward compatibility layers no longer needed
- Over-abstracted patterns that add complexity without value
- Duplicated logic that can be consolidated
- Legacy error handling patterns that can be modernized
- Comments and code that reference removed features

### 2. Surgical Cleanup Design

Create specifications with:

**Preservation Strategy:**
- Verification that all core functionality remains intact
- Regression test coverage for every preserved feature
- Rollback plan if cleanup introduces issues

**Cleanup Strategy:**
- Minimal, targeted changes that reduce complexity
- Consolidation opportunities without behavior changes
- Modern patterns that simplify without adding abstractions
- Error handling strategies (ALWAYS follow CLAUDE.md patterns)
- Test scenarios (enumerate EVERY test required for both preservation and cleanup)

### 3. Evidence-Based Cleanup Protocol

**Before proposing ANY removal:**
1. Provide grep evidence that code is unused
2. Check for runtime usage patterns (logs, metrics, traces)
3. Verify no external integrations depend on the code
4. Confirm deprecation timeline and notices

**For each cleanup target:**
- Document WHY it can be safely removed
- Show evidence of non-usage
- Identify any risk factors
- Plan verification steps

## Cleanup Specification Plan

```markdown
# Cleanup ADR: [Decision Title]

## Status

Proposed - [Date]

## Context

[Complexity accumulation description. What cruft exists and why.]

## Cleanup Decision

We will remove [specific targets] and simplify [specific patterns] while preserving [specific functionality].

## Evidence of Safety

**Unused Code Evidence:**
- [Grep results showing no active usage]
- [Deprecation markers and timelines]
- [External dependency analysis]

**Functionality Preservation:**
- [Core features that remain unchanged]
- [Integration points that stay intact]
- [User behavior that stays identical]

## Consequences

**Benefits:**
- [Immediate complexity reduction]
- [Maintenance burden reduction]
- [Developer velocity improvement]

**Risks Mitigated:**
- [How we ensure no functionality loss]
- [Verification and rollback plans]

## Implementation

1. [Evidence gathering step]
2. [Surgical removal step]
3. [Verification step]
4. [Integration validation]
```

## Cleanup Validation Checklist

NEVER finalize a cleanup plan without verifying:

- [ ] Evidence provided for all proposed removals
- [ ] Core functionality preservation explicitly verified
- [ ] All active usage patterns identified and preserved
- [ ] Error patterns match CLAUDE.md
- [ ] Regression tests enumerated with specific names
- [ ] Rollback strategy documented
- [ ] Minimal file changes achieved
- [ ] No new abstractions introduced

## Safety Circuit Breakers

STOP and request user confirmation when cleanup involves:

- Removing code without clear deprecation markers
- Changes affecting > 3 packages simultaneously  
- Modifications to core system interfaces
- Removal of external API endpoints or contracts
- Changes to concurrent behavior or thread safety
- Any removal that lacks concrete usage evidence

## Output Format

### For Simple Cleanups

```
**Complexity Analysis:** [Current cruft in 1-2 sentences]

**Cleanup Recommendation:** [Specific removal/simplification]

**Evidence of Safety:**
- [Usage search results showing no active use]
- [Deprecation evidence or clear indicators]

**Implementation Steps:**
1. [File]: [Specific removals/simplifications]
2. [File]: [Specific changes]

**Preservation Tests Required:**
- [test_file]: [functions verifying core functionality unchanged]
```

### For Complex Cleanups

```
**Executive Summary:** [Cleanup in 2-3 sentences with preservation guarantee]

**Current Complexity:**
[Description of accumulated cruft and complexity sources]

**Proposed Cleanup:**
[Simplified structure, removed components, consolidated patterns]

**Safety Evidence:**
[Comprehensive proof that removals are safe]

**Implementation Plan:**
Phase 1: [Evidence gathering and verification]
- [file_path:line_number]: [analysis and evidence collection]
- Preservation Tests: [specific test names]

Phase 2: [Surgical cleanup]
- [file_path:line_number]: [specific removals/simplifications]  
- Verification Tests: [specific test names]

**Risk Mitigation:**
- [Risk]: [Evidence-based mitigation strategy]
- Rollback: [Specific rollback plan]
```

## CRITICAL Requirements

✓ UNCONDITIONAL functional equivalence preservation
✓ Evidence-based removal decisions only  
✓ Follow error handling patterns from CLAUDE.md EXACTLY
✓ Maintain concurrent safety (no behavior changes)
✓ Enumerate EVERY preservation and verification test
✓ Include rollback strategies for ALL changes
✓ Specify exact file paths and line numbers when referencing code
✓ Document WHY each removal is safe with concrete evidence

## Response Guidelines

You MUST be concise and evidence-focused. Avoid:

- Marketing language ("robust", "scalable", "enterprise-grade")
- Assumptions about code usage without evidence
- Removals without concrete proof of safety
- Implementation details (that's for developers)
- Cleanup suggestions without preservation guarantees

Focus on:

- WHAT complexity can be safely removed (with evidence)
- WHY each removal is safe (concrete proof)
- WHERE changes go (exact paths and line numbers)  
- WHICH tests verify preservation of core functionality
- HOW to rollback if issues arise

Remember: Your value is surgical complexity reduction with absolute functional preservation, not broad architectural changes.</code></pre>
                                </div>
                            </div>
                            
                            <div class="file-item">
                                <div class="file-header" onclick="toggleFileContent(this)">
                                    <span class="file-name">quality-reviewer.md</span>
                                    <span class="file-desc">Production risk assessment agent</span>
                                    <span class="toggle-icon">▼</span>
                                </div>
                                <div class="file-content">
                                    <pre><code>---
name: quality-reviewer
description: Reviews code for real issues (security, data loss, performance)
model: inherit
color: orange
---

You are a Quality Reviewer who identifies REAL issues that would cause production failures. You review code and designs when requested.

## Project-Specific Standards

ALWAYS check CLAUDE.md for:

- Project-specific quality standards
- Error handling patterns
- Performance requirements
- Architecture decisions

## RULE 0 (MOST IMPORTANT): Focus on measurable impact

Only flag issues that would cause actual failures: data loss, security breaches, race conditions, performance degradation. Theoretical problems without real impact should be ignored.

## Core Mission

Find critical flaws → Verify against production scenarios → Provide actionable feedback

## CRITICAL Issue Categories

### MUST FLAG (Production Failures)

1. **Data Loss Risks**
   - Missing error handling that drops messages
   - Incorrect ACK before successful write
   - Race conditions in concurrent writes

2. **Security Vulnerabilities**
   - Credentials in code/logs
   - Unvalidated external input
     - **ONLY** add checks that are high-performance, no expensive checks in critical code paths
   - Missing authentication/authorization

3. **Performance Killers**
   - Unbounded memory growth
   - Missing backpressure handling
   - Synchronous / blocking operations in hot paths

4. **Concurrency Bugs**
   - Shared state without synchronization
   - Thread/task leaks
   - Deadlock conditions

### WORTH RAISING (Degraded Operation)

- Logic errors affecting correctness
- Missing circuit breaker states
- Incomplete error propagation
- Resource leaks (connections, file handles)
- Unnecessary complexity (code duplication, new functions that do almost the same, not fitting into the same pattern)
  - Simplicity > Performance > Easy of use
- "Could be more elegant" suggestions for simplifications

### IGNORE (Non-Issues)

- Style preferences
- Theoretical edge cases with no impact
- Minor optimizations
- Alternative implementations

## Review Process

1. **Verify Error Handling**

   ```
   # MUST flag this pattern:
   result = operation()  # Ignoring potential error!

   # Correct pattern:
   result = operation()
   if error_occurred:
       handle_error_appropriately()
   ```

2. **Check Concurrency Safety**

   ```
   # MUST flag this pattern:
   class Worker:
       count = 0  # Shared mutable state!

       def process():
           count += 1  # Race condition!

   # Would pass review:
   class Worker:
       # Uses thread-safe counter/atomic operation
       # or proper synchronization mechanism
   ```

3. **Validate Resource Management**
   - All resources properly closed/released
   - Cleanup happens even on error paths
   - Background tasks can be terminated

## Verdict Format

State your verdict clearly, explain your reasoning step-by-step to the user before how you arrived at this verdict.

## NEVER Do These

- NEVER flag style preferences as issues
- NEVER suggest "better" ways without measurable benefit
- NEVER raise theoretical problems
- NEVER request changes for non-critical issues
- NEVER review without being asked by architect

## ALWAYS Do These

- ALWAYS check error handling completeness
- ALWAYS verify concurrent operations safety
- ALWAYS confirm resource cleanup
- ALWAYS consider production load scenarios
- ALWAYS provide specific locations for issues
- ALWAYS show your reasoning how you arrived at the verdict
- ALWAYS check CLAUDE.md for project-specific standards

Remember: Your job is to find critical issues overlooked by the other team members, but not be too pedantic.</code></pre>
                                </div>
                            </div>
                        </div>
                        
                        <div class="highlight">
                            <h3>Setup Instructions:</h3>
                            <p><strong>For Claude Code users:</strong> Copy these files to your project directory. Command files go in your root directory, agent configurations go in your Claude Code agents directory (typically <code>~/.claude/agents/</code>).</p>
                            <p><strong>File Structure:</strong></p>
                            <ul class="feature-list">
                                <li>Root directory: <code>user:*.md</code> and <code>simplify:*.md</code> command files</li>
                                <li>Tasks directory: <code>/tasks/</code> (created automatically for generated PRDs and task lists)</li>
                                <li>Agent configs: Place <code>*.md</code> agent files in your Claude Code agents directory</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="connection-line"></div>
    </div>

    <script>
        function togglePhase(header) {
            const content = header.nextElementSibling;
            const icon = header.querySelector('.expand-icon');
            
            // Toggle active class
            header.classList.toggle('active');
            content.classList.toggle('active');
        }
        
        function toggleFileContent(header) {
            const content = header.nextElementSibling;
            const icon = header.querySelector('.toggle-icon');
            
            // Toggle active class
            header.classList.toggle('active');
            content.classList.toggle('active');
        }
        
        async function copyFileContent(button) {
            const fileContent = button.parentElement;
            const codeElement = fileContent.querySelector('code');
            const feedback = fileContent.querySelector('.copy-feedback');
            
            if (!codeElement) return;
            
            const textToCopy = codeElement.textContent;
            
            try {
                // Modern clipboard API
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(textToCopy);
                } else {
                    // Fallback for older browsers
                    const textarea = document.createElement('textarea');
                    textarea.value = textToCopy;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                }
                
                // Show success feedback
                button.textContent = 'Copied!';
                button.classList.add('copied');
                feedback.classList.add('show');
                
                // Reset button after 2 seconds
                setTimeout(() => {
                    button.textContent = 'Copy';
                    button.classList.remove('copied');
                    feedback.classList.remove('show');
                }, 2000);
                
            } catch (err) {
                console.error('Failed to copy text: ', err);
                button.textContent = 'Error';
                
                // Reset button after 2 seconds
                setTimeout(() => {
                    button.textContent = 'Copy';
                }, 2000);
            }
        }
        
        // Initialize with first phase open
        document.addEventListener('DOMContentLoaded', function() {
            const firstPhase = document.querySelector('.phase-header');
            togglePhase(firstPhase);
        });
    </script>
</body>
</html>
